// Created on: 2020.02.02.
// Author: Adam Csizy
// Last modified: 2020.02.21.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// C language custom extensions:

typedef unsigned short int HashID;

typedef int boolean;

#define true 1
#define false 0

// Global variables, constants

#define INPUT_FILE_NAME "input.txt"
#define RAW_FILE_NAME "raw_text.txt"
#define SYMBOLS_FILE_NAME "symbols.txt"
#define LOG_FILE_NAME "log.txt"
#define WORD_ARRAY_SIZE 46 /* Longest English word: 45 char + \0 */
#define SENTINEL_HASH_ID 0 /* Invalid hash ID for sentinels. Value depends on symbol character inventory defined in function 'rawTextConverter'. See the C ASCII table for more. */
#define SENTINEL_START_INDEX -1 /* Invalid start index for sentinels. */
#define SENTINEL_END_INDEX -1 /* Invalid end index for sentinels. */

static unsigned int TOTAL_SYMBOL_COUNT = 0;

// Program logger

/*
Function 'logger': writes logging information into a log file specified by the LOG_FILE_NAME global variable. 
@param1: log message.
*/
void logger(char message[]){

	FILE *logFile = NULL;
	logFile = fopen(LOG_FILE_NAME,"a");
	if(logFile == NULL)
		return;
	fprintf(logFile,"\n");
	fprintf(logFile,message);
	fclose(logFile);
	logFile = NULL;
}

// Data related structures

typedef struct Symbol{

	char *symbolString;
	unsigned int frequency; //frequency(count) & total -> probability
	double F;

}Symbol;

typedef struct SymbolListElement{

	Symbol symbol;
	struct SymbolListElement *next;
	struct SymbolListElement *prev;

}SymbolListElement;

typedef struct SymbolList{

	signed short int size;
	SymbolListElement *head;
	SymbolListElement *tail;

}SymbolList;

typedef struct BigSymbolList{

	signed int size;
	SymbolListElement *head;
	SymbolListElement *tail;

}BigSymbolList;

typedef struct HashElement{

	unsigned short int hashID;
	SymbolList symbolList;
	struct HashElement *next;
	struct HashElement *prev;

}HashElement;

typedef struct HashTable{

	signed int size;
	HashElement *head;
	HashElement *tail;

}HashTable;

typedef struct Index{

	signed int startIndex;
	signed int endIndex;

}Index;

typedef struct IndexStackElement{

	Index index;
	struct IndexStackElement *next;
	struct IndexStackElement *prev;

}IndexStackElement;

typedef struct IndexStack{

	signed int size;
	IndexStackElement *head;
	IndexStackElement *tail;

}IndexStack;

// Utility functions

/*
Function 'getHashID': returns the hash ID of the given symbol. The hash ID is
generated by adding the numerical values of the symbol's characters.
@param1: string containing the symbol for which the hash ID is being generated.
@return: hash ID of the given symbol.
*/
HashID getHashID(const char symbolString[]){

	unsigned short int hashID = 0;

	while(*symbolString != '\0'){

		hashID = hashID + (*symbolString);
		++symbolString;
	}

	return hashID;
}

/*
Function 'moveHashCursor': moves the hash cursor on the hash element specified
by the index.
@param1: hash cursor.
@param2: hash table.
@param3: index between 0 and size of hash table -1.
*/
void moveHashCursor(HashElement* *cursor, const HashTable *hashTable, const signed int index){

	signed int iter;

	if(NULL == hashTable){

		logger("WARNING: NULL reference in function 'moveHashCursor'.");
	}
	else{

		if((index > (hashTable->size - 1)) || (0 == hashTable->size) || (index < 0)){

			logger("WARNING: Invalid index in function 'moveHashCursor'.");
			*cursor = NULL;
		}
		else{

			for(iter = 0, *cursor = hashTable->head->next;iter < index;++iter){

				*cursor = (*cursor)->next;
			}
		}
	}
}

/*
Function 'moveSymbolListCursor': moves the symbol list cursor on the symbol list
element specified by the index.
@param1: symbol list cursor.
@param2: symbol list.
@param3: index between 0 and size of symbol list -1.
*/
void moveSymbolListCursor(SymbolListElement* *cursor, const SymbolList *symbolList, const signed short int index){

	signed short int iter;

	if(NULL == symbolList){

		logger("WARNING: NULL reference in function 'moveSymbolListCursor'.");
	}
	else{

		if((index > (symbolList->size - 1)) || (0 == symbolList->size) || (index < 0)){

			logger("WARNING: Invalid index in function 'moveSymbolListCursor'.");
			*cursor = NULL;
		}
		else{

			for(iter = 0, *cursor = symbolList->head->next;iter < index;++iter){
				
				*cursor = (*cursor)->next;
			}
		}
	}
}

/*
Function 'moveBigSymbolListCursor': moves the symbol list cursor on the symbol list
element specified by the index.
@param1: symbol list cursor.
@param2: symbol list.
@param3: index between 0 and size of symbol list -1.
*/
void moveBigSymbolListCursor(SymbolListElement* *cursor, const BigSymbolList *bigSymbolList, const signed int index){

	signed int iter;

	if(NULL == bigSymbolList){

		logger("WARNING: NULL reference in function 'moveBigSymbolListCursor'.");
	}
	else{

		if((index > (bigSymbolList->size - 1)) || (0 == bigSymbolList->size) || (index < 0)){

			logger("WARNING: Invalid index in function 'moveBigSymbolListCursor'.");
			*cursor = NULL;
		}
		else{

			for(iter = 0, *cursor = bigSymbolList->head->next;iter < index;++iter){

				*cursor = (*cursor)->next;
			}
		}
	}
}

/*
Function 'swapSymbolListElement': swaps the given symbol list elements.
@param1: first symbol list element.
@param2: second symbol list element.
*/
void swapSymbolListElement(SymbolListElement *first, SymbolListElement *second){

	SymbolListElement temp;

	if((NULL == first) || (NULL == second)){

		logger("WARNING: NULL reference in function 'swapSymbolListElement'.");
	}
	else{

		if((first->next != second) && (second->next != first)){

			// Handle nonadjacent elements
			temp.next = first->next;
			temp.prev = first->prev;

			first->prev->next = second;
			first->next->prev = second;

			second->prev->next = first;
			second->next->prev = first;

			first->next = second->next;
			first->prev = second->prev;

			second->next = temp.next;
			second->prev = temp.prev;

		}
		else{

			// Handle adjacent elements
			if(first->next == second){

				first->prev->next = second;
				second->next->prev = first;

				first->next = second->next;
				second->prev = first->prev;

				first->prev = second;
				second->next = first;
			}
			else{

				swapSymbolListElement(second, first);
			}
		}
	}
}

/*
Function 'partition': partitions the given symbol list in 2 parts defined by the
pivot value. Pivot is being selected as the last element of the given symbol list.
Source: https://www.techiedelight.com/iterative-implementation-of-quicksort/
@param1: symbol list to be partitioned.
@param2: starting index of the given symbol list, 0 or higher.
@param3: ending index of the given symbol list, size of symbol list -1 or lower.
@return: pivot index or -1 (error).
*/
signed int partition(BigSymbolList *bigSymbolList, const signed int startIndex, const signed int endIndex){

	signed int i, p;
	SymbolListElement *pivot, *iCursor, *pCursor;

	if(NULL == bigSymbolList){

		logger("WARNING: NULL reference in function 'partition'.");
		return -1;
	}
	else{

		if((startIndex < 0) || (startIndex > (bigSymbolList->size - 1)) || (endIndex > (bigSymbolList->size - 1))){

			logger("WARNING: Invalid index in function 'partition'.");
			return -1;
		}
		else{

			i = startIndex;
			p = startIndex;

			moveBigSymbolListCursor(&pivot, bigSymbolList, endIndex);
			moveBigSymbolListCursor(&iCursor, bigSymbolList, i);
			moveBigSymbolListCursor(&pCursor, bigSymbolList, p);

			for(i = startIndex;i < endIndex;++i, moveBigSymbolListCursor(&iCursor, bigSymbolList, i)){

				/* Descending order by symbol frequency. */
				if(iCursor->symbol.frequency >= pivot->symbol.frequency){

					swapSymbolListElement(iCursor, pCursor);

					++p;
					moveBigSymbolListCursor(&pCursor, bigSymbolList, p);
				}
			}

			swapSymbolListElement(pCursor, pivot);

			return p;
		}
	}
}

/*
Function 'pushFrontIndexStack': allocates, initialises by the given parameters
and inserts an index stack element to the top of the given index stack.
@param1: index stack.
@param2: start index.
@param3: end index.
@return: function status -1 (error) or 0 (success).
*/
int pushFrontIndexStack(IndexStack *indexStack, const signed int startIndex, const signed int endIndex){

	if(NULL == indexStack){

		logger("WARNING: NULL reference in function 'pushFrontIndexStack'.");
		return -1;
	}
	else{

		IndexStackElement *newIndexStackElement = (IndexStackElement*)malloc(sizeof(IndexStackElement));

		if(NULL == newIndexStackElement){

			logger("Unable to allocate memory for index stack element in function 'pushFrontIndexStack'.");
			return -1;
		}

		newIndexStackElement->index.startIndex = startIndex;
		newIndexStackElement->index.endIndex = endIndex;

		newIndexStackElement->next = indexStack->head->next;
		newIndexStackElement->prev = indexStack->head;

		indexStack->head->next->prev = newIndexStackElement;
		indexStack->head->next = newIndexStackElement;

		++(indexStack->size);

		return 0;
	}
}

/*
Function 'popFrontIndexStack': copies the start and end indices to the given variables and
removes the first index stack element from the top of the given index stack.
@param1: index stack.
@param2: start index variable.
@param3: end index variable.
*/
void popFrontIndexStack(IndexStack *indexStack, signed int *startIndex, signed int *endIndex){

	IndexStackElement *indexStackElement;

	if((NULL == indexStack) || (NULL == startIndex) || (NULL == endIndex)){

		logger("WARNING: NULL reference in function 'popFrontIndexStack'.");
	}
	else{

		if(indexStack->size > 0){

			indexStackElement = indexStack->head->next;

			*startIndex = indexStackElement->index.startIndex;
			*endIndex = indexStackElement->index.endIndex;

			indexStack->head->next = indexStackElement->next;
			indexStackElement->next->prev = indexStack->head;

			free(indexStackElement);

			--(indexStack->size);
		}
	}
}

// Data related functions

/*
Function 'initSymbolByParam': initialises the given symbol by the given parameters.
@param1: symbol to be initialised.
@param2: string containing the symbol.
@param3: symbol frequency.
@param4: F.
*/
void initSymbolByParam(Symbol *symbol, const char symbolString[], const unsigned int frequency , const double F){

	if(NULL == symbol){

		logger("WARNING: NULL reference in function 'initSymbolByParam'.");
	}
	else{

		symbol->symbolString = (char*)malloc((strlen(symbolString)+1)*sizeof(char));

		if(NULL == symbol->symbolString){

			logger("WARNING: Unable to allocate memory for symbol string in function 'initSymbolByParam'.");
		}
		else{

			strcpy(symbol->symbolString, symbolString);
		}

		symbol->frequency = frequency;
		symbol->F = F;
	}
}

/*
Function 'initSymbolListElementByParam': initialises the given symbol list element by the given
symbol parameter.
@param1: symbol list element to be initialised.
@param2: symbol.
*/
void initSymbolListElementByParam(SymbolListElement *symbolListElement, const Symbol *symbol){

	if((NULL == symbolListElement) || (NULL == symbol)){

		logger("WARNING: NULL reference in function 'initSymbolListElementByParam'.");
	}
	else{

		initSymbolByParam(&(symbolListElement->symbol), symbol->symbolString, symbol->frequency, symbol->F);

		symbolListElement->next = NULL;
		symbolListElement->prev = NULL;
	}
}

/*
Function 'initSymbolList': initialises the given symbol list.
@param1: symbol list to be initialised.
*/
void initSymbolList(SymbolList *symbolList){

	if(NULL == symbolList){

		logger("WARNING: NULL reference in function 'initSymbolList'.");
	}
	else{

		symbolList->size = 0;

		symbolList->head = (SymbolListElement*)malloc(sizeof(SymbolListElement));
		symbolList->tail = (SymbolListElement*)malloc(sizeof(SymbolListElement));

		if((NULL == symbolList->head) || (NULL == symbolList->tail)){

			logger("WARNING: Unable to allocate memory for symbol list head and/or tail in function 'initSymbolList'.");
		
			free(symbolList->head);
			free(symbolList->tail);
		}
		else{

			symbolList->head->next = symbolList->tail;
			symbolList->head->prev = NULL;

			symbolList->tail->next = NULL;
			symbolList->tail->prev = symbolList->head;
		}
	}
}

/*
Function 'initBigSymbolList': initialises the given big symbol list.
@param1: big symbol list to be initialised.
*/
void initBigSymbolList(BigSymbolList *bigSymbolList){

	if(NULL == bigSymbolList){

		logger("WARNING: NULL reference in function 'initBigSymbolList'.");
	}
	else{

		bigSymbolList->size = 0;

		bigSymbolList->head = (SymbolListElement*)malloc(sizeof(SymbolListElement));
		bigSymbolList->tail = (SymbolListElement*)malloc(sizeof(SymbolListElement));
	
		if((NULL == bigSymbolList->head) || (NULL == bigSymbolList->tail)){

			logger("WARNING: Unable to allocate memory for big symbol list head and/or tail in function 'initBigSymbolList'.");
		
			free(bigSymbolList->head);
			free(bigSymbolList->tail);
		}
		else{

			bigSymbolList->head->next = bigSymbolList->tail;
			bigSymbolList->head->prev = NULL;

			bigSymbolList->tail->next = NULL;
			bigSymbolList->tail->prev = bigSymbolList->head;
		}
	}
}

/*
Function 'initHashElementByParam': initialises the given hash element by the given parameters.
@param1: hash element to be initialised.
@param2: hash ID.
*/
void initHashElementByParam(HashElement *hashElement, const HashID hashID){
	
	if(NULL == hashElement){

		logger("WARNING: NULL reference in function 'initHashElementByParam'.");
	}
	else{

		hashElement->hashID = hashID;
	
		initSymbolList(&(hashElement->symbolList));

		hashElement->next = NULL;
		hashElement->prev = NULL;
	}
}

/*
Function 'initHashTable': initialises the given hash table.
@param1: hash table to be initialised.
*/
void initHashTable(HashTable *hashTable){

	if(NULL == hashTable){

		logger("WARNING: NULL reference in function 'initHashTable'.");
	}
	else{

		hashTable->size = 0;

		hashTable->head = (HashElement*)malloc(sizeof(HashElement));
		hashTable->tail = (HashElement*)malloc(sizeof(HashElement));

		if((NULL == hashTable->head) || (NULL == hashTable->tail)){

			logger("WARNING: Unable to allocate memory for hash table head and/or tail in function 'initHashTable'.");

			free(hashTable->head);
			free(hashTable->tail);
		}
		else{

			hashTable->head->hashID = SENTINEL_HASH_ID;
			hashTable->head->next = hashTable->tail;
			hashTable->head->prev = NULL;

			hashTable->tail->hashID = SENTINEL_HASH_ID;
			hashTable->tail->next = NULL;
			hashTable->tail->prev = hashTable->head;
		}
	}
}

/*
Function 'initIndexStack': initialises the given index stack.
@param1: index stack to be initialised.
*/
void initIndexStack(IndexStack *indexStack){

	if(NULL == indexStack){

		logger("WARNING: NULL reference in function 'initIndexStack'.");
	}
	else{

		indexStack->size = 0;

		indexStack->head = (IndexStackElement*)malloc(sizeof(IndexStackElement));
		indexStack->tail = (IndexStackElement*)malloc(sizeof(IndexStackElement));

		if((NULL == indexStack->head) || (NULL == indexStack->tail)){

			logger("WARNING: Unable to allocate memory for index stack head and/or tail in function 'initIndexStack'.");
		
			free(indexStack->head);
			free(indexStack->tail);
		}
		else{

			indexStack->head->index.startIndex = SENTINEL_START_INDEX;
			indexStack->head->index.endIndex = SENTINEL_END_INDEX;
			indexStack->head->next = indexStack->tail;
			indexStack->head->prev = NULL;

			indexStack->tail->index.startIndex = SENTINEL_START_INDEX;
			indexStack->tail->index.endIndex = SENTINEL_END_INDEX;
			indexStack->tail->next = NULL;
			indexStack->tail->prev = indexStack->head;
		}
	}
}

/*
Function 'insertHashElementBetween': inserts the given hash element between the given hash elements.
@param1: hash element to be inserted.
@param2: previous hash element.
@param3: next hash element.
*/
void insertHashElementBetween(HashElement *newElem, HashElement *prevElem, HashElement *nextElem){


	if((NULL == newElem) || (NULL == prevElem) || (NULL == nextElem)){

		logger("WARNING: NULL reference in function 'insertHashElementBetween'.");
	}
	else{

		newElem->next = nextElem;
		newElem->prev = prevElem;

		prevElem->next = newElem;
		nextElem->prev = newElem;
	}
}

/*
Function 'insertSymbolListElementBetween': inserts the given symbol list element between the given symbol list elements.
@param1: symbol list element to be inserted.
@param2: previous symbol list element.
@param3: next symbol list element.
*/
void insertSymbolListElementBetween(SymbolListElement *newElem, SymbolListElement *prevElem, SymbolListElement *nextElem){

	if((NULL == newElem) || (NULL == prevElem) || (NULL == nextElem)){

		logger("WARNING: NULL reference in function 'insertSymbolListElementBetween'.");
	}
	else{

		newElem->next = nextElem;
		newElem->prev = prevElem;

		prevElem->next = newElem;
		nextElem->prev = newElem;
	}
}

/*
Function 'concatSymbolList': concatenates symbol lists from the given hash table
into a single symbol list (push back).
@param1: initialised symbol list.
@param2: hash table containing the symbol lists to be concatenated.
*/
void concatSymbolList(BigSymbolList *bigSymbolList, HashTable *hashTable){

	HashElement *hashElement;

	if((NULL == bigSymbolList) || (NULL == hashTable)){

		logger("WARNING: NULL reference in function 'concatSymbolList'.");
	}
	else{

		for(hashElement = hashTable->head->next;hashElement != hashTable->tail;hashElement = hashElement->next){

			/* Setting border element pointers of the source list section. */
			hashElement->symbolList.head->next->prev = bigSymbolList->tail->prev;
			hashElement->symbolList.tail->prev->next = bigSymbolList->tail;

			/* Setting border element pointers of the target list section. */
			bigSymbolList->tail->prev->next = hashElement->symbolList.head->next;
			bigSymbolList->tail->prev = hashElement->symbolList.tail->prev;

			/* Setting sentinel pointers of the source list. */
			hashElement->symbolList.head->next = hashElement->symbolList.tail;
			hashElement->symbolList.tail->prev = hashElement->symbolList.head;

			/* Setting size of the source and target lists. */
			bigSymbolList->size = (bigSymbolList->size) + (hashElement->symbolList.size);
			hashElement->symbolList.size = 0;
		}
	}
}

/*
Function 'deleteSymbol': deletes the given symbol.
@param1: symbol to be deleted.
*/
void deleteSymbol(Symbol *symbol){

	if(NULL == symbol){

		logger("WARNING: NULL reference in function 'deleteSymbol'.");
	}
	else{

		symbol->F = 0.0;
		symbol->frequency = 0;

		free(symbol->symbolString);
		symbol->symbolString = NULL;
	}
}

/*
Function 'deleteSymbolList': decomposes and deletes the given symbol list.
@param1: symbol list to be deleted.
*/
void deleteSymbolList(SymbolList *symbolList){

	SymbolListElement *symbolListElement = NULL;

	if(NULL == symbolList){

		logger("WARNING: NULL reference in function 'deleteSymbolList'.");
	}
	else{

		while(symbolList->size > 0){

			symbolListElement = symbolList->head->next;

			deleteSymbol(&(symbolListElement->symbol));

			symbolList->head->next = symbolListElement->next;
			symbolListElement->next->prev = symbolList->head;

			symbolListElement->next = NULL;
			symbolListElement->prev = NULL;
			free(symbolListElement);

			--(symbolList->size);

			symbolListElement = NULL;
		}

		free(symbolList->head);
		free(symbolList->tail);

		symbolList->head = NULL;
		symbolList->tail = NULL;
	}
}

/*
Function 'deleteBigSymbolList': decomposes and deletes the given big symbol list.
@param1: big symbol list to be deleted.
*/
void deleteBigSymbolList(BigSymbolList *bigSymbolList){

	SymbolListElement *symbolListElement = NULL;

	if(NULL == bigSymbolList){

		logger("WARNING: NULL reference in function 'deleteBigSymbolList'.");
	}
	else{

		while(bigSymbolList->size > 0){

			symbolListElement = bigSymbolList->head->next;

			deleteSymbol(&(symbolListElement->symbol));

			bigSymbolList->head->next = symbolListElement->next;
			symbolListElement->next->prev = bigSymbolList->head;

			symbolListElement->next = NULL;
			symbolListElement->prev = NULL;
			free(symbolListElement);

			--(bigSymbolList->size);

			symbolListElement = NULL;
		}

		free(bigSymbolList->head);
		free(bigSymbolList->tail);

		bigSymbolList->head = NULL;
		bigSymbolList->tail = NULL;
	}
}

/*
Function 'deleteHashTable': decomposes and deletes the given hash table.
@param1: hash table to be deleted.
*/
void deleteHashTable(HashTable *hashTable){

	HashElement *hashElement = NULL;

	if(NULL == hashTable){

		logger("WARNING: NULL reference in function 'deleteHashTable'.");
	}
	else{

		while(hashTable->size > 0){

			hashElement = hashTable->head->next;
			deleteSymbolList(&(hashElement->symbolList));

			hashTable->head->next = hashElement->next;
			hashElement->next->prev = hashTable->head;

			hashElement->next = NULL;
			hashElement->prev = NULL;
			free(hashElement);

			--(hashTable->size);

			hashElement = NULL;
		}

		free(hashTable->head);
		free(hashTable->tail);

		hashTable->head = NULL;
		hashTable->tail = NULL;
	}
}

// Sorting functions

/*
Function 'quickSortByFrequency': sorts the symbol list elements in the given
symbol list in descending order by frequency using iterative quick sort algorithm.
Source: https://www.geeksforgeeks.org/iterative-quick-sort/
@param1: symbol list to be quick sorted.
*/
void quickSortByFrequency(BigSymbolList *bigSymbolList){

	signed int pivotIndex, startIndex, endIndex;
	IndexStack indexStack;

	if(NULL == bigSymbolList){

		logger("WARNING: NULL reference in function 'quickSortByFrequency'.");
	}
	else{

		initIndexStack(&indexStack);

		pushFrontIndexStack(&indexStack, 0, (bigSymbolList->size)-1);

		while(indexStack.size > 0){

			popFrontIndexStack(&indexStack, &startIndex, &endIndex);

			pivotIndex = partition(bigSymbolList, startIndex, endIndex);

			if(pivotIndex-1 > startIndex){

				pushFrontIndexStack(&indexStack, startIndex, pivotIndex-1);
			}

			if(pivotIndex+1 < endIndex){

				pushFrontIndexStack(&indexStack, pivotIndex+1, endIndex);
			}
		}
	}
}

// Search functions

/*
Function 'getSymbolListByHashID': searches for a symbol list in the given hash table
with the given hash ID. If no symbol list was found a new hash element is being added
to the hash table with an appropriate hash ID and symbol list.
@param1: hash table where the symbols are being stored.
@param2: hash ID of the symbol(list) in target of search.
@return: pointer to a symbol list specified by the given hash ID. In case of error
a NULL pointer is returned.
*/
SymbolList* getSymbolListByHashID(HashTable *hashTable, const HashID hashID){

	HashElement *hashCursor = NULL, *newHashElement = NULL;

	signed int infIndex = 0, supIndex = ((hashTable->size)-1), midIndex;
	
	while(infIndex <= supIndex){
		
		midIndex = (infIndex + supIndex)/2;
		moveHashCursor(&hashCursor, hashTable, midIndex);

		if(hashID == hashCursor->hashID)
			return &(hashCursor->symbolList);

		if(hashCursor->hashID > hashID)
			supIndex = (midIndex - 1);
		else 
			infIndex = (midIndex + 1);
	}

	newHashElement = (HashElement*)malloc(sizeof(HashElement));

	if(NULL == newHashElement){

		logger("WARNING: Unable to allocate memory for new hash element in function 'getSymbolListByHashID'.");
		return NULL;
	}

	initHashElementByParam(newHashElement, hashID);

	if(0 == hashTable->size){
		
		insertHashElementBetween(newHashElement, hashTable->head, hashTable->tail);
	}
	else{

		/*
		Condition ' supIndex < midIndex ' is FORBIDDEN with unsigned types.
		Eg.: midIndex equals 0 and supIndex is decremented to -1 -> overflow.
		*/

		if(infIndex > midIndex){

			/* Insert after midIndex. */

			insertHashElementBetween(newHashElement, hashCursor, hashCursor->next);
		}
		else{

			/* Insert before midIndex. */

			insertHashElementBetween(newHashElement, hashCursor->prev, hashCursor);
		}
	}

	++(hashTable->size);

	return &(newHashElement->symbolList);
}

/*
Function 'getSymbolBySymbolString': searches for a symbol in the given symbol list with
the given symbol string. If no symbol was found a new symbol list element is being added
to the symbol list with an appropriate symbol.
@param1: symbol list where the symbols are being stored.
@param2: symbol string in target of search.
@return: memory adress of the symbol specified by the given symbol string. In case of
error a NULL pointer is returned.
*/
Symbol* getSymbolBySymbolString(SymbolList *symbolList, const char symbolString[]){

	Symbol newSymbol;
	SymbolListElement *symbolListCursor = NULL, *newSymbolListElement = NULL;

	signed short int infIndex = 0, supIndex = (symbolList->size)-1, midIndex;

	while(infIndex <= supIndex){

		midIndex = (infIndex + supIndex)/2;
		moveSymbolListCursor(&symbolListCursor, symbolList, midIndex);

		if(0 == strcmp(symbolString, symbolListCursor->symbol.symbolString))
			return &(symbolListCursor->symbol);

		if(strcmp(symbolString, symbolListCursor->symbol.symbolString) < 0)
			supIndex = (midIndex - 1);
		else
			infIndex = (midIndex + 1);
	}

	newSymbolListElement = (SymbolListElement*)malloc(sizeof(SymbolListElement));

	if(NULL == newSymbolListElement){

		logger("WARNING: Unable to allocate memory for new symbol list element in function 'getSymbolBySymbolString'.");
		return NULL;
	}

	initSymbolByParam(&newSymbol, symbolString, 0, 0.0);
	initSymbolListElementByParam(newSymbolListElement, &newSymbol);

	if(0 == symbolList->size){

		insertSymbolListElementBetween(newSymbolListElement, symbolList->head, symbolList->tail);
	}
	else{

		/*
		Condition ' supIndex < midIndex ' is FORBIDDEN with unsigned types.
		Eg.: midIndex equals 0 and supIndex is decremented to -1 -> overflow.
		*/

		if(infIndex > midIndex){

			/* Insert after midIndex. */

			insertSymbolListElementBetween(newSymbolListElement,symbolListCursor,symbolListCursor->next);
		}
		else{

			/* Insert before midIndex. */

			insertSymbolListElementBetween(newSymbolListElement,symbolListCursor->prev,symbolListCursor);
		}
	}

	++(symbolList->size);

	return &(newSymbolListElement->symbol);
}

// Symbol handler functions

/*
Function 'addSymbol': adds a symbol to the data structure. If the symbol is already
in the data structure symbol frequency is being increased.
@param1: string containing the symbol to be added.
@param2: hash table where the symbol is going to be stored.
@return: function status -1 (error) or 0 (success).
*/
int addSymbol(const char symbolString[], HashTable *hashTable){

	Symbol *symbol;
	SymbolList *symbolList;
	
	symbolList = getSymbolListByHashID(hashTable, getHashID(symbolString));

	if(NULL == symbolList){
		
		logger("WARNING: Unable to add symbol in function 'addSymbol'.\nSymbol list not found.");
		return -1;
	}

	symbol = getSymbolBySymbolString(symbolList, symbolString);

	if(NULL == symbol){

		logger("WARNING: Unable to add symbol in function 'addSymbol'.\nSymbol not found.");
		return -1;
	}

	++(symbol->frequency);

	return 0;
}

/*
Function 'setF': calculates and sets the F value for each symbol in the given
big symbol list. Formula: F[i] = SUM[k=0;i-1](p[k]), where 'p[k]' is the probability
of symbol 'k'.
@param1: big symbol list. Note that list elements must be in descending order
according to frequency.
@param2: total number of processed symbols.
*/
void setF(BigSymbolList *bigSymbolList, const unsigned int totalSymbolCount){

	unsigned int totalFrequency = 0;
	SymbolListElement *symbolListElement = NULL;

	if(NULL == bigSymbolList){

		logger("WARNING: NULL reference in function 'setF'.");
	}
	else{

		for(symbolListElement = bigSymbolList->head->next;
						(symbolListElement != NULL) && (symbolListElement != bigSymbolList->tail);
							symbolListElement = symbolListElement->next){

						symbolListElement->symbol.F = (double)((double)totalFrequency/(double)totalSymbolCount);
						totalFrequency += symbolListElement->symbol.frequency;
		}
	}
}

/*
Function 'getShannonCode': generates the Shannon code of the given symbol.
@param1: symbol of which the Shannon code is being generated.
@param2: total number of processed symbols.
@param3: pointer to the generated code string.
*/
void getShannonCode(const Symbol *symbol, const unsigned int totalSymbolCount, char* *code){

	unsigned int length, i;
	double probability, temp, locF;

	if(NULL == symbol){

		logger("WARNING: NULL reference in function 'getShannonCode'.");
	}
	else{

		probability = (double)((double)(symbol->frequency)/(double)totalSymbolCount);

		/* Formula: length = ld(1/probablility) and ld(x) = log(x)/log(2) */
		temp = log(1.0/probability) / log(2.0);
		if(temp > (int)temp){

			length = (int)temp + 1;
		}
		else{

			length = (int)temp;
		}

		*code = (char*)malloc((length+1)*sizeof(char));

		if(NULL == *code){

			logger("WARNING: Unable to allocate memory for code string in function 'getShannonCode'.");
		}
		else{

			i = 0;
			locF = symbol->F;
			while(i < length){

				locF *= 2;
				if(locF < 1){

					(*code)[i] = '0';
					++i;
				}
				else{

					locF -= 1;
					(*code)[i] = '1';
					++i;
				}
			}
			(*code)[length] = '\0';
		}
	}
}

// File management related functions

/*
Function 'rawTextConverter': converts text to 'raw text' format.
@param1: name of the source file.
@param2: name of the target file.
@return: function status -1 (error) or 0 (success).
*/
int rawTextConverter(const char sourceFileName[], const char targetFileName[]){

	FILE *sourceFile = NULL, *targetFile = NULL;
	char character;

	sourceFile = fopen(sourceFileName,"r");

	if(NULL == sourceFile){

		logger("ERROR: Unable to open source file in function 'rawTextConverter'.");
		return -1;
	}

	targetFile = fopen(targetFileName,"w");

	if(NULL == targetFile){

		logger("ERROR: Unable to open target file in function 'rawTextConverter'.");
		fclose(sourceFile);
		sourceFile = NULL;
		return -1;
	}

	/* 
	Text converter cycle. Converts input text to 'raw text' by character.
	Upper case characters are being converted to lower case characters.
	Relevant characters: A-Z, a-z
	Other characters including numbers are being ignored.
	For conditions see the C language ASCII char table.
	Note that changes in conditions in function 'rawTextConverter' require
	the revision of the cycle core and conditions in function 'rawTextProcessor'.
	*/
	while(1 == fscanf(sourceFile, "%c", &character)){

		if(character > 0x40 && character < 0x5b){
			fprintf(targetFile, "%c", character+0x20);
		}
		else{
			if(character > 0x60 && character < 0x7b){
				fprintf(targetFile, "%c", character);
			}
			else{
				if(character == 0x20){
					fprintf(targetFile, "%c", character);
				}
			}
		}
	}

	fclose(sourceFile);
	sourceFile = NULL;
	fclose(targetFile);
	targetFile = NULL;

	return 0;
}

/*
Function 'rawTextProcessor': processes data from the 'raw text' file.
@param1: name of the 'raw text' file.
@param2: hash table where the processed data is being stored.
@return: function status -1 (error) or 0 (success).
*/
int rawTextProcessor(const char rawTextFileName[], HashTable *hashTable){

	FILE *rawTextFile = NULL;
	int wordIndex = 0;
	char character, word[WORD_ARRAY_SIZE];

	typedef enum{start, stop, space, letter} State;
	State currState = start;

	rawTextFile=fopen(rawTextFileName,"r");

	if(NULL == rawTextFile){
		logger("ERROR: Unable to open 'raw text' file in function 'rawTextProcessor'.");
		return -1;
	}

	/*
	Text processor cycle (state machine). Reads words (symbols) by character and adds them to
	a list containing symbols. Cycle conditions and data processing methods heavily
	depend on the character inventory of the 'raw text'. Note that changes in function
	'rawTextConverter' require the revision of the cycle core and conditions
	in function 'rawTextProcessor'.
	*/
	while(currState != stop){

		switch(currState){

		case start:

			if(fscanf(rawTextFile, "%c", &character) != 1)
				currState = stop;
			else
				if(' ' == character)
					currState = space;
				else{
					word[wordIndex] = character;
					++wordIndex;
					currState = letter;
				}
			break;

		case space:

			if(fscanf(rawTextFile, "%c", &character) != 1)
				currState = stop;
			else
				if(' ' == character)
					currState = space;
				else{
					word[wordIndex] = character;
					++wordIndex;
					currState = letter;
				}
			break;

		case letter:

			if(fscanf(rawTextFile, "%c", &character) != 1){
				word[wordIndex] = '\0';
				if(0 == addSymbol(word, hashTable))
					++TOTAL_SYMBOL_COUNT;
				wordIndex = 0;
				currState = stop;
			}
			else
				if(' ' == character){
					word[wordIndex] = '\0';
					if(0 == addSymbol(word, hashTable))
						++TOTAL_SYMBOL_COUNT;
					wordIndex = 0;
					currState = space;
				}
				else{
					if(wordIndex < (WORD_ARRAY_SIZE-1)){
						word[wordIndex] = character;
						++wordIndex;
						currState = letter;
					}
					else{ /*remains of the word being treated as a new word*/
						word[wordIndex] = '\0';
						if(0 == addSymbol(word, hashTable))
							++TOTAL_SYMBOL_COUNT;
						wordIndex = 0;
						word[wordIndex] = character;
						++wordIndex;
						currState = letter;
						logger("WARNING: A word truncated in function 'rawTextProcessor'.\nGiven WORD_ARRAY_SIZE is exceeded.");
					}
					
				}
			break;
		}

	}

	fclose(rawTextFile);
	rawTextFile = NULL;

	return 0;
}

/*
Function 'exportSymbols': generates and exports symbol - code pairs into a text file.
@param1: big symbol list.
@param2: name of the target file in which the symbol - code pairs are being exported.
@param3: total number of processed symbols.
@return: function status -1 (error) or 0 (success).
*/
int exportSymbols(const BigSymbolList *bigSymbolList, const char targetFileName[], const unsigned int totalSymbolCount){

	char *code = NULL;
	SymbolListElement *symbolListElement = NULL;
	FILE *targetFile = NULL;

	if(NULL == bigSymbolList){

		logger("WARNING: NULL reference in function 'exportSymbols'.");
		return -1;
	}

	targetFile = fopen(targetFileName, "w");

	if(NULL == targetFile){

		logger("ERROR: Unable to open target file in function 'exportSymbols'.");
		return -1;
	}

	printf("Exporting symbols to %s ...\n", SYMBOLS_FILE_NAME);

	fprintf(targetFile, "INFO: Number of exported symbols: %d.\n", bigSymbolList->size);

	for(symbolListElement = bigSymbolList->head->next;
					(symbolListElement != NULL) && (symbolListElement != bigSymbolList->tail);
						symbolListElement = symbolListElement->next){

							getShannonCode(&(symbolListElement->symbol), totalSymbolCount, &code);

							if(NULL == code){

								logger("WARNING: Unable to export symbol in function 'exportSymbol'.");
							}
							else{

								fprintf(targetFile,"%s %s\n", symbolListElement->symbol.symbolString, code);
								free(code);
								code = NULL;
							}
	}

	fclose(targetFile);
	targetFile = NULL;

	return 0;
}

/*
Function 'convertText': 
@return: function status -1 (error) or 0 (success).
*/
int convertText(void){

	// TODO
	return 0;
}

// Coder related functions

/*
Function 'generateShannonCode': generates and writes Shannon code into the output file. 
@param1: hash table containing the symbols.
@return: function status -1 (error) or 0 (success).
*/
int generateShannonCode(HashTable *hashTable){

	BigSymbolList bigSymbolList;

	initBigSymbolList(&bigSymbolList);

	concatSymbolList(&bigSymbolList, hashTable);

	quickSortByFrequency(&bigSymbolList);

	setF(&bigSymbolList, TOTAL_SYMBOL_COUNT);

	/*
	At this point the attributes for each symbol in the list have been set.
	Shannon code can be generated at any time as long as the symbol list exists.
 
	Note the symbols are in descending order by frequency. It can be used for
	further optimisation (eg.: linear search from first element due to symbol
	probability on text conversion). In any other case a sorting function
	must be called on the symbol list.
	*/

	/* Call sorting function here if needed. */

	/* Call symbol exporting function if needed. */
	exportSymbols(&bigSymbolList, SYMBOLS_FILE_NAME, TOTAL_SYMBOL_COUNT);

	/* Call text converter function if needed. */
	// TODO Call text converter function.

	deleteBigSymbolList(&bigSymbolList);

	return 0;
}

// Main function of the program 

int main(int argc, char* argv[])
{

	HashTable hashTable;

	logger("\t-\t-\t-\t-\t-\t-\t-NEW RUN-\t-\t-\t-\t-\t-\t-");

	/* Program Component Initialisation Block */

	printf("Initialising program components...\n");

	initHashTable(&hashTable);

	/* File Converter Block*/

	printf("Converting %s file...\n", RAW_FILE_NAME);

	if(rawTextConverter(INPUT_FILE_NAME/*argv[0]*/,RAW_FILE_NAME) != 0){

		logger("ERROR: Function 'rawRextConverter' failed. Program terminated.");
		return -1;
	}

	/* File Reader Block */

	printf("Processing data. This might take a while...\n");

	if(rawTextProcessor(RAW_FILE_NAME, &hashTable) != 0){

		logger("ERROR: Function 'rawTextProcessor' failed. Program terminated.");
		return -1;
	}

	/* Shannon Code Generator and File Writer Block */

	printf("Generating Shannon code. This might take a while...\n");

	if(generateShannonCode(&hashTable) != 0){

		logger("ERROR: Function 'generateShannonCode' failed. Program terminated.");
		return -1;
	}

	/* Data Structure Decomposition Block */

	deleteHashTable(&hashTable);

	printf("End of program.");

	return 0;
}

/*
FUTURE DEVELOPMENT FIELDS:

1: Evaluate number of independent hashIDs and number of independent symbols per symbol list.
Use static arrays instead of dynamic arrays. Improve search algorythms due to static array by indexing.
Is contiguous memory allocation (static array!) possible with 'such' extension?

2: Optimize search algorithms by using relative indexing.
	(eg.: moveHashCursor(actualCursorPos, relativeIndex{...}))

3: New data storage structure and algorithms based on alphabetical order, hash ID, symbol probability weight.

		1st layer -> Alphabetic domains according to first character (A-Z,0-9)
		2nd layer -> Hash tables according to hash IDs
		3rd layer -> Symbols in alphabetical order in lists

4: Capability of processing numbers.

5: Randomize pivot and modify algorythm (if necessary) in function 'partition'.

6: Indicate error with negative return value in function 'generateShannonCode'.

7: Outsource program components into source files and headers to improve code maintenance.

8: Implement text converter function ('convertText').

*/