// Created: 2019.07.19.
// Creator: Adam
// Last modified: 2019.09.03.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// C language custom extensions:

typedef int boolean;

#define true 1
#define false 0

// Global variables, constants

#define RAW_FILE_NAME "raw_text.txt"
#define CODE_FILE_NAME "code.txt"
#define LOG_FILE_NAME "log.txt"
#define WORD_ARRAY_SIZE 46 /* Longest English word: 45 char + \0 */
#define SENTINEL_HASH_ID 0 /* Invalid hash ID for sentinels. Value depends on symbol character inventory defined in function 'rawTextConverter'. See the C ASCII table for more. */
static unsigned int TOTAL_SYMBOL_COUNT=0;

// Program logger

/*
Function 'logger': writes logging information into a log file specified by the LOG_FILE_NAME global variable. 
@param1: log message.
*/
void logger(char message[]){

	FILE *logFile=NULL;
	logFile=fopen(LOG_FILE_NAME,"a");
	if(logFile == NULL)
		return;
	fprintf(logFile,"\n");
	fprintf(logFile,message);
	fclose(logFile);
	logFile=NULL;
}

// Data related structures

typedef struct Symbol{

	char *symbolString;
	unsigned int frequency; //frequency(count) & total -> probability
	double F;

}Symbol;

typedef struct SymbolListElement{

	Symbol symbol;
	struct SymbolListElement *next;
	struct SymbolListElement *prev;

}SymbolListElement; /*Kell egy pointer mezõ a shannonkódolásnál!*/

typedef struct SymbolList{

	signed short int size;
	SymbolListElement *head;
	SymbolListElement *tail;

}SymbolList;

typedef struct HashElement{

	unsigned short int hashID;
	SymbolList *symbolList;
	struct HashElement *next;
	struct HashElement *prev;

}HashElement;

typedef struct HashTable{

	signed int size;
	HashElement *head;
	HashElement *tail;

}HashTable;

// Utility functions

/*
Function 'getHashID': returns the hash ID of the given symbol. The hash ID is
generated by adding the numerical values of the symbol's characters.
@param1: string containing the symbol for which the hash ID is being generated.
@return: hash ID of the given symbol.
*/
unsigned short int getHashID(char symbolString[]){

	unsigned short int hashID=0;

	while(*symbolString != '\0'){

		hashID=hashID+*symbolString;
		++symbolString;
	}

	return hashID;
}

/*
Function 'moveHashCursor': moves the hash cursor on the hash element specified
by the index. DO NOT USE with empty hash table.
@param1: hash cursor.
@param2: hash table.
@param3: index between 0 and size of hash table -1.
*/
void moveHashCursor(HashElement* cursor, HashTable *hashTable, signed int index){

	signed int iter;

	for(iter=0, cursor=hashTable->head->next;iter < index;++iter)
		cursor=cursor->next;
}

/*
Function 'moveSymbolListCursor': moves the symbol list cursor on the symbol list
element specified by the index. DO NOT USE with empty symbol list.
@param1: symbol list cursor.
@param2: symbol list.
@param3: index between 0 and size of symbol list -1.
*/
void moveSymbolListCursor(SymbolListElement *cursor, SymbolList *symbolList, signed short int index){

	signed short int iter;

	for(iter=0, cursor=symbolList->head->next;iter < index;++iter)
		cursor=cursor->next;
}

// Search functions

/*
Function 'getSymbolListByHashID': searches for a symbol list in the given hash table
with the given hash ID. If no symbol list was found a new hash element is being added
to the hash table with an appropriate hash ID and symbol list.
@param1: hash table where the symbols are being stored.
@param2: hash ID of the symbol(list) in target of search.
@return: pointer to a symbol list specified by the given hash ID. In case of error
a NULL pointer is returned.
*/
SymbolList* getSymbolListByHashID(HashTable *hashTable, unsigned short int hashID){

	HashElement *hashCursor=NULL;

	signed int infIndex=0, supIndex=(hashTable->size)-1, midIndex;

	midIndex=(infIndex+supIndex)/2;
	moveHashCursor(hashCursor, hashTable, midIndex);
	
	while(infIndex <= supIndex){
		
		midIndex=(infIndex+supIndex)/2;
		moveHashCursor(hashCursor, hashTable, midIndex);

		if(hashCursor->hashID == hashID)
			return hashCursor->symbolList;

		if(hashCursor->hashID > hashID)
			supIndex=midIndex-1;
		else
			infIndex=midIndex+1;
	}


	/*
	Condition ' supIndex < midIndex ' is FORBIDDEN with unsigned types.
	Eg.: midIndex equals 0 and supIndex is decremented to -1 -> overflow.
	*/

	if(infIndex > midIndex){

		/* Insert after midIndex. */

		if(insertNewHashElementBetween(hashID, hashCursor, hashCursor->next) != 0){

			logger("WARNING: Calling function 'insertNewHashElementBetween' failed in function 'getSymbolListByHashID'.");
			return NULL;
		}

		++hashTable->size;

		return hashCursor->next->symbolList;
	}
	else{

		/* Insert before midIndex. */

		if(insertNewHashElementBetween(hashID, hashCursor->prev, hashCursor) != 0){

			logger("WARNING: Calling function 'insertNewHashElementBetween' failed in function 'getSymbolListByHashID'.");
			return NULL;
		}

		++hashTable->size;

		return hashCursor->prev->symbolList;
	}
}

/*
Function 'getSymbolBySymbolString': searches for a symbol in the given symbol list with
the given symbol string. If no symbol was found a new symbol list element is being added
to the symbol list with an appropriate symbol.
@param1: symbol list where the symbols are being stored.
@param2: symbol string in target of search.
@return: memory adress of the symbol specified by the given symbol string. In case of
error a NULL pointer is returned.
*/
Symbol* getSymbolBySymbolString(SymbolList *symbolList, char symbolString[]){

	SymbolListElement *symbolListCursor=NULL;

	signed short int infIndex=0, supIndex=(symbolList->size)-1, midIndex;

	midIndex=(infIndex+supIndex)/2;
	moveSymbolListCursor(symbolListCursor, symbolList, midIndex);

	while(infIndex <= supIndex){

		midIndex=(infIndex+supIndex)/2;
		moveSymbolListCursor(symbolListCursor, symbolList, midIndex);

		if(strcmp(symbolString, symbolListCursor->symbol.symbolString) == 0)
			return &(symbolListCursor->symbol);

		if(strcmp(symbolString, symbolListCursor->symbol.symbolString) < 0)
			supIndex=midIndex-1;
		else
			infIndex=midIndex+1;
	}

	/*
	Condition ' supIndex < midIndex ' is FORBIDDEN with unsigned types.
	Eg.: midIndex equals 0 and supIndex is decremented to -1 -> overflow.
	*/

	if(infIndex > midIndex){

		/* Insert after midIndex. */

		if(insertNewSymbolListElementBetween(symbolString, symbolListCursor, symbolListCursor->next) != 0){

			logger("Calling function 'insertNewSymbolListElementBetween' failed in function 'getSymbolBySymbolString'.");
			return NULL;
		}

		++symbolList->size;

		return &(symbolListCursor->next->symbol);
	}
	else{

		/* Insert before midIndex. */

		if(insertNewSymbolListElementBetween(symbolString, symbolListCursor->prev, symbolListCursor) != 0){

			logger("Calling function 'insertNewSymbolListElementBetween' failed in function 'getSymbolBySymbolString'.");
			return NULL;
		}

		++symbolList->size;

		return &(symbolListCursor->prev->symbol);
	}
}

// Data related functions

/*
Function 'initHashTable': initialises the given hash table.
@param1: hash table to be initialised.
*/
void initHashTable(HashTable *hashTable){

	hashTable->size=0;

	hashTable->head=(HashElement*)malloc(sizeof(HashElement));
	hashTable->tail=(HashElement*)malloc(sizeof(HashElement));

	if(hashTable->head == NULL || hashTable->tail == NULL){

		logger("Unable to allocate memory for hash table head and/or tail in function 'initHashTable'.");
		return;
	}

	hashTable->head->hashID=SENTINEL_HASH_ID;
	hashTable->head->symbolList=NULL;
	hashTable->head->next=hashTable->tail;
	hashTable->head->prev=NULL;

	hashTable->tail->hashID=SENTINEL_HASH_ID;
	hashTable->tail->symbolList=NULL;
	hashTable->tail->next=NULL;
	hashTable->tail->prev=hashTable->head;
}

/*
Function 'initHashElementByParam': initialises the given hash element by the given parameters.
@param1: hash element to be initialised.
@param2: hash ID.
@param3: symbol list.
*/
void initHashElementByParam(HashElement *hashElement, unsigned short int hashID, SymbolList *symbolList){
	
	hashElement->hashID=hashID;
	hashElement->symbolList=symbolList;
	hashElement->next=NULL;
	hashElement->prev=NULL;
}

/*
Function 'initSymbolList': initialises the given symbol list.
@param1: symbol list to be initialised.
*/
void initSymbolList(SymbolList *symbolList){

	symbolList->size=0;

	symbolList->head=(SymbolListElement*)malloc(sizeof(SymbolListElement));
	symbolList->tail=(SymbolListElement*)malloc(sizeof(SymbolListElement));

	if(symbolList->head == NULL || symbolList->tail == NULL){

		logger("WARNING: Unable to allocate memory for symbol list head and/or tail in function 'initSymbolList'.");
		return;
	}

	symbolList->head->next=symbolList->tail;
	symbolList->head->prev=NULL;

	symbolList->tail->next=NULL;
	symbolList->tail->prev=symbolList->head;
}

/*
Function 'initSymbolByParam': initialises the given symbol by the given parameters.
@param1: symbol to be initialised.
@param2: string containing the symbol.
@param3: symbol frequency.
@param4: F.
*/
void initSymbolByParam(Symbol *symbol, char symbolString[], unsigned int frequency , double F){

	symbol->symbolString=(char*)malloc((strlen(symbolString)+1)*sizeof(char));

	if(symbol->symbolString == NULL){

		symbol->frequency=frequency;
		symbol->F=F;

		logger("WARNING: Unable to allocate memory for symbol string in function 'initSymbolByParam'.");

		return;
	}

	strcpy(symbol->symbolString, symbolString);

	symbol->frequency=frequency;
	symbol->F=F;
}

/*
Function 'insertNewHashElementBetween': allocates, initialises and inserts a
hash element between the given hash elements.
@param1: hash ID.
@param2: previous hash element.
@param3: next hash element.
@return: function status -1 (error) or 0 (success).
*/
int insertNewHashElementBetween(unsigned short int hashID, HashElement *prev, HashElement *next){

	SymbolList *newSymbolList=(SymbolList*)malloc(sizeof(SymbolList));
	HashElement *newHashElement=(HashElement*)malloc(sizeof(HashElement));

	if(newSymbolList == NULL || newHashElement == NULL){

		logger("WARNING: Unable to allocate memory for hash element and/or symbol list in function 'insertNewHashElementBetween'.");
		return -1;
	}
	
	initSymbolList(newSymbolList);
	initHashElementByParam(newHashElement, hashID, newSymbolList);

	newHashElement->next=next;
	newHashElement->prev=prev;

	return 0;
}

/*
Function 'insertNewSymbolListElementBetween': allocates, initialises and inserts a
symbol list element between the given symbol list elements.
@param1: string containing the symbol.
@param2: previous symbol list element.
@param3: next symbol list element.
@return: function status -1 (error) or 0 (success).
*/
int insertNewSymbolListElementBetween(char symbolString[], SymbolListElement *prev, SymbolListElement *next){

	SymbolListElement *newSymbolListElement=(SymbolListElement*)malloc(sizeof(SymbolListElement));

	if(newSymbolListElement == NULL){

		logger("WARNING: Unable to allocate memory for symbol list element in function 'insertNewSymbolListElementBetween'.");

		return -1;
	}

	initSymbolByParam(&(newSymbolListElement->symbol), symbolString, 0, 0.0);

	newSymbolListElement->next=next;
	newSymbolListElement->prev=prev;

	return 0;
}

/*
Function 'addSymbol': adds a symbol to the data structure. If the symbol is already
in the data structure symbol frequency is being increased.
@param1: string containing the symbol to be added.
@param2: hash table where the symbol is going to be stored.
@return: function status -1 (error) or 0 (success).
*/
int addSymbol(char symbolString[], HashTable *hashTable){

	Symbol *symbol;
	SymbolList *symbolList;
	
	symbolList=getSymbolListByHashID(hashTable, getHashID(symbolString));

	if(symbolList == NULL){
		
		logger("WARNING: Unable to add symbol in function 'addSymbol'.\nSymbol list not found.");
		return -1;
	}

	symbol=getSymbolBySymbolString(symbolList, symbolString);

	if(symbol == NULL){

		logger("WARNING: Unable to add symbol in function 'addSymbol'.\nSymbol not found.");
		return -1;
	}

	++symbol->frequency;

	return 0;
}

// File management related functions

/*
Function 'rawTextConverter': converts text to 'raw text' format.
@param1: name of the source file.
@param2: name of the target file.
@return: function status -1 (error) or 0 (success).
*/
int rawTextConverter(char sourceFileName[], char targetFileName[]){

	FILE *sourceFile=NULL, *targetFile=NULL;
	char character;

	sourceFile=fopen(sourceFileName,"r");

	if(sourceFile == NULL){
		logger("ERROR: Unable to open source file in function 'rawTextConverter'.");
		return -1;
	}

	targetFile=fopen(targetFileName,"w");

	if(targetFile == NULL){
		logger("ERROR: Unable to open target file in function 'rawTextConverter'.");
		fclose(sourceFile);
		sourceFile=NULL;
		return -1;
	}

	/* 
	Text converter cycle. Converts input text to 'raw text' by character.
	Upper case characters are being converted to lower case characters.
	Relevant characters: A-Z, a-z
	Other characters including numbers are being ignored.
	For conditions see the C language ASCII char table.
	Note that changes in conditions in function 'rawTextConverter' require
	the revision of the cycle core and conditions in function 'rawTextProcessor'.
	*/
	while(fscanf(sourceFile, "%c", &character) == 1){

		if(character > 0x40 && character < 0x5b){
			fprintf(targetFile, "%c", character+0x20);
		}
		else{
			if(character > 0x60 && character < 0x7b)
				fprintf(targetFile, "%c", character);
			else{
				if(character == 0x20)
					fprintf(targetFile, "%c", character);
				else
					/*void action*/;
			}
		}
	}

	fclose(sourceFile);
	sourceFile=NULL;
	fclose(targetFile);
	targetFile=NULL;

	return 0;
}

/*
Function 'rawTextProcessor': processes data from the 'raw text' file.
@param1: name of the 'raw text' file.
@param2: hash table where the processed data is being stored.
@return: function status -1 (error) or 0 (success).
*/
int rawTextProcessor(char rawTextFileName[], HashTable *hashTable){

	FILE *rawTextFile=NULL;
	int wordIndex=0;
	char character, word[WORD_ARRAY_SIZE];

	typedef enum{start, stop, space, letter} State;
	State currState=start;

	rawTextFile=fopen(rawTextFileName,"r");

	if(rawTextFile == NULL){
		logger("ERROR: Unable to open 'raw text' file in function 'rawTextProcessor'.");
		return -1;
	}

	/*
	Text processor cycle (state machine). Reads words (symbols) by character and adds them to
	a list containing symbols. Cycle conditions and data processing methods heavily
	depend on the character inventory of the 'raw text'. Note that changes in function
	'rawTextConverter' require the revision of the cycle core and conditions
	in function 'rawTextProcessor'.
	*/
	while(currState != stop){

		switch(currState){

		case start:

			if(fscanf(rawTextFile, "%c", &character) != 1)
				currState=stop;
			else
				if(character == ' ')
					currState=space;
				else{
					word[wordIndex]=character;
					++wordIndex;
					currState=letter;
				}
			break;

		case space:

			if(fscanf(rawTextFile, "%c", &character) != 1)
				currState=stop;
			else
				if(character == ' ')
					currState=space;
				else{
					word[wordIndex]=character;
					++wordIndex;
					currState=letter;
				}
			break;

		case letter:

			if(fscanf(rawTextFile, "%c", &character) != 1){
				word[wordIndex]='\0';
				if(addSymbol(word, hashTable) == 0)
					++TOTAL_SYMBOL_COUNT;
				wordIndex=0;
				currState=stop;
			}
			else
				if(character == ' '){
					word[wordIndex]='\0';
					if(addSymbol(word, hashTable) == 0)
						++TOTAL_SYMBOL_COUNT;
					wordIndex=0;
					currState=space;
				}
				else{
					if(wordIndex < (WORD_ARRAY_SIZE-1)){
						word[wordIndex]=character;
						++wordIndex;
						currState=letter;
					}
					else{ /*remains of the word being treated as a new word*/
						word[wordIndex]='\0';
						if(addSymbol(word, hashTable) == 0)
							++TOTAL_SYMBOL_COUNT;
						wordIndex=0;
						word[wordIndex]=character;
						++wordIndex;
						currState=letter;
						logger("WARNING: A word truncated in function 'rawTextProcessor'.\nGiven WORD_ARRAY_SIZE is exceeded.");
					}
					
				}
			break;
		}

	}

	fclose(rawTextFile);
	rawTextFile=NULL;

	return 0;
}


// Main function of the program 

int main(int argc, char* argv[])
{

	/* Program Component Initialisation Block */
	HashTable hashTable;
	initHashTable(&hashTable);

	/* File Converter Block*/
	if(rawTextConverter(argv[0],RAW_FILE_NAME) != 0){
		logger("ERROR: Function 'rawRextConverter' failed. Program terminated.");
		return -1;
	}

	/* File Reader Block */
	if(rawTextProcessor(RAW_FILE_NAME, &hashTable) != 0){
		logger("ERROR: Function 'rawTextProcessor' failed. Program terminated.");
		return -1;
	}

	/* Shannon Coder Block */

	/* File Writer Block */

	/* Program Component and Data Structure Decomposition free() */

	return 0;
}

/*
FUTURE DEVELOPMENT FIELDS:

1: Evaluate number of independent hashIDs and number of independent symbols per symbol list/hash element.
Use static arrays instead of dynamic arrays. Improve search algorythms due to static array by indexing.
Is contiguous memory allocation (static array!) possible with 'such' extension?

2: Optimize search algorithms by using relative indexing.
	(Eg.: moveHashCursor(lastCursorPos, relativeIndex{...}))

3: New data storage structure and algorithms based on alphabetical order, hash ID, symbol probability weigh.
	Tip#1:
		1st lvl -> Alphabetic groups according to 1st letter(and number)
		2nd lvl -> Hash tables according to hash IDs
		3rd lvl -> Symbols in alphabetic order in lists

4: Use const where possible (eg.: function parameter list)

5: Outsource the initialisation funtions from the insertNew[...]Between() functions to the calling function.
	Tip#1:
		-> allocate locally
		-> check for allocation exceptions locally
		-> initialise with function call
		-> insert with function call

6: Capability of processing numbers.

*/