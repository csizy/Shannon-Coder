// Created on: 2020.02.02.
// Author: Adam Csizy
// Last modified: 2020.02.02.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// C language custom extensions:

typedef int boolean;

#define true 1
#define false 0

// Global variables, constants

#define RAW_FILE_NAME "raw_text.txt"
#define CODE_FILE_NAME "code.txt"
#define LOG_FILE_NAME "log.txt"
#define WORD_ARRAY_SIZE 46 /* Longest English word: 45 char + \0 */
#define SENTINEL_HASH_ID 0 /* Invalid hash ID for sentinels. Value depends on symbol character inventory defined in function 'rawTextConverter'. See the C ASCII table for more. */
#define SENTINEL_START_INDEX -1 /* Invalid start index for sentinels. */
#define SENTINEL_END_INDEX -1 /* Invalid end index for sentinels. */

static unsigned int TOTAL_SYMBOL_COUNT = 0;

// Program logger

/*
Function 'logger': writes logging information into a log file specified by the LOG_FILE_NAME global variable. 
@param1: log message.
*/
void logger(char message[]){

	FILE *logFile = NULL;
	logFile = fopen(LOG_FILE_NAME,"a");
	if(logFile == NULL)
		return;
	fprintf(logFile,"\n");
	fprintf(logFile,message);
	fclose(logFile);
	logFile = NULL;
}

// Data related structures

typedef struct Symbol{

	char *symbolString;
	unsigned int frequency; //frequency(count) & total -> probability
	double F;

}Symbol;

typedef struct SymbolListElement{

	Symbol symbol;
	struct SymbolListElement *next;
	struct SymbolListElement *prev;

}SymbolListElement;

typedef struct SymbolList{

	signed short int size;
	SymbolListElement *head;
	SymbolListElement *tail;

}SymbolList;

typedef struct BigSymbolList{

	signed int size;
	SymbolListElement *head;
	SymbolListElement *tail;

}BigSymbolList;

typedef struct HashElement{

	unsigned short int hashID;
	SymbolList symbolList;
	struct HashElement *next;
	struct HashElement *prev;

}HashElement;

typedef struct HashTable{

	signed int size;
	HashElement *head;
	HashElement *tail;

}HashTable;

typedef struct Index{

	signed int startIndex;
	signed int endIndex;

}Index;

typedef struct IndexStackElement{

	Index index;
	struct IndexStackElement *next;
	struct IndexStackElement *prev;

}IndexStackElement;

typedef struct IndexStack{

	signed int size;
	IndexStackElement *head;
	IndexStackElement *tail;

}IndexStack;

// Utility functions

/*
Function 'getHashID': returns the hash ID of the given symbol. The hash ID is
generated by adding the numerical values of the symbol's characters.
@param1: string containing the symbol for which the hash ID is being generated.
@return: hash ID of the given symbol.
*/
unsigned short int getHashID(const char symbolString[]){

	unsigned short int hashID = 0;

	while(*symbolString != '\0'){

		hashID = hashID + (*symbolString);
		++symbolString;
	}

	return hashID;
}

/*
Function 'moveHashCursor': moves the hash cursor on the hash element specified
by the index. DO NOT USE with empty hash table.
@param1: hash cursor.
@param2: hash table.
@param3: index between 0 and size of hash table -1.
*/
void moveHashCursor(HashElement *cursor, const HashTable *hashTable, const signed int index){

	signed int iter;

	if(NULL == hashTable){

		logger("WARNING: NULL reference in function 'moveHashCursor'.");
	}
	else{

		for(iter = 0, cursor = hashTable->head->next;iter < index;++iter){

			cursor = cursor->next;
		}
	}
}

/*
Function 'moveSymbolListCursor': moves the symbol list cursor on the symbol list
element specified by the index. DO NOT USE with empty symbol list.
@param1: symbol list cursor.
@param2: symbol list.
@param3: index between 0 and size of symbol list -1.
*/
void moveSymbolListCursor(SymbolListElement *cursor, const SymbolList *symbolList, const signed short int index){

	signed short int iter;

	for(iter = 0, cursor = symbolList->head->next;iter < index;++iter){
		cursor = cursor->next;
	}
}

/*
Function 'moveBigSymbolListCursor': moves the symbol list cursor on the symbol list
element specified by the index. DO NOT USE with empty symbol list.
@param1: symbol list cursor.
@param2: symbol list.
@param3: index between 0 and size of symbol list -1.
*/
void moveBigSymbolListCursor(SymbolListElement *cursor, const BigSymbolList *symbolList, const signed int index){

	signed int iter;

	for(iter = 0, cursor = symbolList->head->next;iter < index;++iter){
		cursor = cursor->next;
	}
}

/*
Function 'swapSymbolListElement': swaps the given symbol list elements.
@param1: first symbol list element.
@param2: second symbol list element.
*/
void swapSymbolListElement(SymbolListElement *first, SymbolListElement *second){

	SymbolListElement temp;

	temp.next = first->next;
	temp.prev = first->prev;

	first->prev->next = second;
	first->next->prev = second;

	second->prev->next = first;
	second->next->prev = first;

	first->next = second->next;
	first->prev = second->prev;

	second->next = temp.next;
	second->prev = temp.prev;
}

/*
Function 'partition': partitions the given symbol list in 2 parts defined by the
pivot value. Pivot is being selected as the last element of the given symbol list.
Source: https://www.techiedelight.com/iterative-implementation-of-quicksort/
@param1: symbol list to be partitioned.
@param2: starting index of the given symbol list, 0 or higher.
@param3: ending index of the given symbol list, size of symbol list -1 or lower.
@return: pivot index.
*/
signed int partition(BigSymbolList *symbolList, const signed int startIndex, const signed int endIndex){

	signed int i, pIndex;
	SymbolListElement *pivot, *iCursor, *pIndexCursor;

	moveBigSymbolListCursor(pivot, symbolList, endIndex);
	pIndex = startIndex;

	for(i = startIndex;i < endIndex;++i){

		moveBigSymbolListCursor(iCursor, symbolList, i);

		/* Descending order by symbol frequency. */
		if(iCursor->symbol.frequency >= pivot->symbol.frequency){

			moveBigSymbolListCursor(pIndexCursor, symbolList, pIndex);
			swapSymbolListElement(iCursor, pIndexCursor);

			++pIndex;
		}
	}

	moveBigSymbolListCursor(pIndexCursor, symbolList, pIndex);
	swapSymbolListElement(pIndexCursor, pivot);

	return pIndex;
}

/*
Function 'pushFrontIndexStack': allocates, initialises by the given parameters
and inserts an index stack element to the top of the given index stack.
@param1: index stack.
@param2: start index.
@param3: end index.
@return: function status -1 (error) or 0 (success).
*/
int pushFrontIndexStack(IndexStack *indexStack, const signed int startIndex, const signed int endIndex){

	IndexStackElement *newIndexStackElement = (IndexStackElement*)malloc(sizeof(IndexStackElement));

	if(newIndexStackElement == NULL){

		logger("Unable to allocate memory for index stack element in function 'pushFrontIndexStack'.");
		return -1;
	}

	newIndexStackElement->index.startIndex = startIndex;
	newIndexStackElement->index.endIndex = endIndex;

	newIndexStackElement->next = indexStack->head->next;
	newIndexStackElement->prev = indexStack->head;

	indexStack->head->next->prev = newIndexStackElement;
	indexStack->head->next = newIndexStackElement;

	++(indexStack->size);

	return 0;
}

/*
Function 'popFrontIndexStack': copies the start and end indices to the given variables and
removes the first index stack element from the top of the given index stack.
@param1: index stack.
@param2: start index variable.
@param3: end index variable.
*/
void popFrontIndexStack(IndexStack *indexStack, signed int *startIndex, signed int *endIndex){

	IndexStackElement *indexStackElement;

	if(indexStack->size > 0){

		indexStackElement = indexStack->head->next;

		*startIndex = indexStackElement->index.startIndex;
		*endIndex = indexStackElement->index.endIndex;

		indexStack->head->next = indexStackElement->next;
		indexStackElement->next->prev = indexStack->head;

		free(indexStackElement);

		--(indexStack->size);
	}
}

// Order functions

/*
Function 'quickSortByFrequency': sorts the symbol list elements in the given
symbol list in descending order by frequency using iterative quick sort algorithm.
Source: https://www.geeksforgeeks.org/iterative-quick-sort/
@param1: symbol list to be quick sorted.
*/
void quickSortByFrequency(BigSymbolList *symbolList){

	signed int pivotIndex, startIndex, endIndex;

	IndexStack indexStack;
	initIndexStack(&indexStack);

	pushFrontIndexStack(&indexStack, 0, (symbolList->size)-1);

	while(indexStack.size > 0){

		popFrontIndexStack(&indexStack, &startIndex, &endIndex);

		pivotIndex = partition(symbolList, startIndex, endIndex);

		if(pivotIndex-1 > startIndex){

			pushFrontIndexStack(&indexStack, startIndex, pivotIndex-1);
		}

		if(pivotIndex+1 < endIndex){

			pushFrontIndexStack(&indexStack, pivotIndex+1, endIndex);
		}
	}
}

// Data related functions

/*
Function 'initHashTable': initialises the given hash table.
@param1: hash table to be initialised.
*/
void initHashTable(HashTable *hashTable){

	if(NULL == hashTable){

		logger("WARNING: NULL reference in function 'initHashTable'.");
	}
	else{

		hashTable->size = 0;

		hashTable->head = (HashElement*)malloc(sizeof(HashElement));
		hashTable->tail = (HashElement*)malloc(sizeof(HashElement));

		if((NULL == hashTable->head) || (NULL == hashTable->tail)){

			logger("WARNING: Unable to allocate memory for hash table head and/or tail in function 'initHashTable'.");

			free(hashTable->head);
			free(hashTable->tail);
		}
		else{

			hashTable->head->hashID = SENTINEL_HASH_ID;
			hashTable->head->next = hashTable->tail;
			hashTable->head->prev = NULL;

			hashTable->tail->hashID = SENTINEL_HASH_ID;
			hashTable->tail->next = NULL;
			hashTable->tail->prev = hashTable->head;
		}
	}
}

/*
Function 'initHashElementByParam': initialises the given hash element by the given parameters.
@param1: hash element to be initialised.
@param2: hash ID.
*/
void initHashElementByParam(HashElement *hashElement, const unsigned short int hashID){
	
	if(NULL == hashElement){

		logger("WARNING: NULL reference in function 'initHashElementByParam'.");
	}
	else{

		hashElement->hashID = hashID;
	
		initSymbolList(&(hashElement->symbolList));

		hashElement->next = NULL;
		hashElement->prev = NULL;
	}
}

/*
Function 'initSymbolList': initialises the given symbol list.
@param1: symbol list to be initialised.
*/
void initSymbolList(SymbolList *symbolList){

	if(NULL == symbolList){

		logger("WARNING: NULL reference in function 'initSymbolList'.");
	}
	else{

		symbolList->size = 0;

		symbolList->head = (SymbolListElement*)malloc(sizeof(SymbolListElement));
		symbolList->tail = (SymbolListElement*)malloc(sizeof(SymbolListElement));

		if((NULL == symbolList->head) || (NULL == symbolList->tail)){

			logger("WARNING: Unable to allocate memory for symbol list head and/or tail in function 'initSymbolList'.");
		
			free(symbolList->head);
			free(symbolList->tail);
		}
		else{

			symbolList->head->next = symbolList->tail;
			symbolList->head->prev = NULL;

			symbolList->tail->next = NULL;
			symbolList->tail->prev = symbolList->head;
		}
	}
}

/*
Function 'initSymbolListElementByParam': initialises the given symbol list element by the given
symbol parameter.
@param1: symbol list element to be initialised.
@param2: symbol.
*/
void initSymbolListElementByParam(SymbolListElement *symbolListElement, const Symbol *symbol){

	if((NULL == symbolListElement) || (NULL == symbol)){

		logger("WARNING: NULL reference in function 'initSymbolListElementByParam'.");
	}
	else{

		initSymbolByParam(&(symbolListElement->symbol), symbol->symbolString, symbol->frequency, symbol->F);

		symbolListElement->next = NULL;
		symbolListElement->prev = NULL;
	}
}

/*
Function 'initBigSymbolList': initialises the given big symbol list.
@param1: big symbol list to be initialised.
*/
void initBigSymbolList(BigSymbolList *bigSymbolList){

	bigSymbolList->size = 0;

	bigSymbolList->head = (SymbolListElement*)malloc(sizeof(SymbolListElement));
	bigSymbolList->tail = (SymbolListElement*)malloc(sizeof(SymbolListElement));
	
	if((bigSymbolList->head == NULL) || (bigSymbolList->tail == NULL)){

		logger("WARNING: Unable to allocate memory for big symbol list head and/or tail in function 'initBigSymbolList'.");
		
		free(bigSymbolList->head);
		free(bigSymbolList->tail);
	}
	else{

		bigSymbolList->head->next = bigSymbolList->tail;
		bigSymbolList->head->prev = NULL;

		bigSymbolList->tail->next = NULL;
		bigSymbolList->tail->prev = bigSymbolList->head;
	}
}

/*
Function 'initIndexStack': initialises the given index stack.
@param1: index stack to be initialised.
*/
void initIndexStack(IndexStack *indexStack){

	if(NULL == indexStack){

		logger("WARNING: NULL reference in function 'initIndexStack'.");
	}
	else{

		indexStack->size = 0;

		indexStack->head = (IndexStackElement*)malloc(sizeof(IndexStackElement));
		indexStack->tail = (IndexStackElement*)malloc(sizeof(IndexStackElement));

		if((NULL == indexStack->head) || (NULL == indexStack->tail)){

			logger("WARNING: Unable to allocate memory for index stack head and/or tail in function 'initIndexStack'.");
		
			free(indexStack->head);
			free(indexStack->tail);
		}
		else{

			indexStack->head->index.startIndex = SENTINEL_START_INDEX;
			indexStack->head->index.endIndex = SENTINEL_END_INDEX;
			indexStack->head->next = indexStack->tail;
			indexStack->head->prev = NULL;

			indexStack->tail->index.startIndex = SENTINEL_START_INDEX;
			indexStack->tail->index.endIndex = SENTINEL_END_INDEX;
			indexStack->tail->next = NULL;
			indexStack->tail->prev = indexStack->head;
		}
	}
}

/*
Function 'initSymbolByParam': initialises the given symbol by the given parameters.
@param1: symbol to be initialised.
@param2: string containing the symbol.
@param3: symbol frequency.
@param4: F.
*/
void initSymbolByParam(Symbol *symbol, const char symbolString[], const unsigned int frequency , const double F){

	if(NULL == symbol){

		logger("WARNING: NULL reference in function 'initSymbolByParam'.");
	}
	else{

		symbol->symbolString = (char*)malloc((strlen(symbolString)+1)*sizeof(char));

		if(NULL == symbol->symbolString){

			logger("WARNING: Unable to allocate memory for symbol string in function 'initSymbolByParam'.");
		}
		else{

			strcpy(symbol->symbolString, symbolString);
		}

		symbol->frequency = frequency;
		symbol->F = F;
	}
}

/*
Function 'insertHashElementBetween': inserts the given hash element between the given hash elements.
@param1: hash element to be inserted.
@param2: previous hash element.
@param3: next hash element.
*/
void insertHashElementBetween(HashElement *newElem, HashElement *prevElem, HashElement *nextElem){


	if((NULL == newElem) || (NULL == prevElem) || (NULL == nextElem)){

		logger("WARNING: NULL reference in function 'insertHashElementBetween'.");
	}
	else{

		newElem->next = nextElem;
		newElem->prev = prevElem;

		prevElem->next = newElem;
		nextElem->prev = newElem;
	}
}

/*
Function 'insertSymbolListElementBetween': inserts the given symbol list element between the given symbol list elements.
@param1: symbol list element to be inserted.
@param2: previous symbol list element.
@param3: next symbol list element.
*/
void insertSymbolListElementBetween(SymbolListElement *newElem, SymbolListElement *prevElem, SymbolListElement *nextElem){

	if((NULL == newElem) || (NULL == prevElem) || (NULL == nextElem)){

		logger("WARNING: NULL reference in function 'insertSymbolListElementBetween'.");
	}
	else{

		newElem->next = nextElem;
		newElem->prev = prevElem;

		prevElem->next = newElem;
		nextElem->prev = newElem;
	}
}

/*
Function 'addSymbol': adds a symbol to the data structure. If the symbol is already
in the data structure symbol frequency is being increased.
@param1: string containing the symbol to be added.
@param2: hash table where the symbol is going to be stored.
@return: function status -1 (error) or 0 (success).
*/
int addSymbol(const char symbolString[], HashTable *hashTable){

	Symbol *symbol;
	SymbolList *symbolList;
	
	symbolList = getSymbolListByHashID(hashTable, getHashID(symbolString));

	if(NULL == symbolList){
		
		logger("WARNING: Unable to add symbol in function 'addSymbol'.\nSymbol list not found.");
		return -1;
	}

	symbol = getSymbolBySymbolString(symbolList, symbolString);

	if(NULL == symbol){

		logger("WARNING: Unable to add symbol in function 'addSymbol'.\nSymbol not found.");
		return -1;
	}

	++(symbol->frequency);

	return 0;
}

/*
Function 'concatSymbolList': concatenates symbol lists from the given hash table
into a single symbol list (push back).
@param1: initialised symbol list.
@param2: hash table containing the symbol lists to be concatenated.
*/
void concatSymbolList(BigSymbolList *symbolList, HashTable *hashTable){

	HashElement *hashElement;

	for(hashElement=hashTable->head->next;hashElement != hashTable->tail;hashElement=hashElement->next){

		/* Setting border element pointers of the source list section. */
		hashElement->symbolList->head->next->prev=symbolList->tail->prev;
		hashElement->symbolList->tail->prev->next=symbolList->tail;

		/* Setting border element pointers of the target list section. */
		symbolList->tail->prev->next=hashElement->symbolList->head->next;
		symbolList->tail->prev=hashElement->symbolList->tail->prev;

		/* Setting sentinel pointers of the source list. */
		hashElement->symbolList->head->next=hashElement->symbolList->tail;
		hashElement->symbolList->tail->prev=hashElement->symbolList->head;

		/* Setting size of the source and target lists. */
		symbolList->size=(symbolList->size)+(hashElement->symbolList->size);
		hashElement->symbolList->size=0;
	}
}

// Search functions

/*
Function 'getSymbolListByHashID': searches for a symbol list in the given hash table
with the given hash ID. If no symbol list was found a new hash element is being added
to the hash table with an appropriate hash ID and symbol list.
@param1: hash table where the symbols are being stored.
@param2: hash ID of the symbol(list) in target of search.
@return: pointer to a symbol list specified by the given hash ID. In case of error
a NULL pointer is returned.
*/
SymbolList* getSymbolListByHashID(HashTable *hashTable, const unsigned short int hashID){

	HashElement *hashCursor = NULL, *newHashElement = NULL;

	signed int infIndex = 0, supIndex = ((hashTable->size)-1), midIndex;

	midIndex = (infIndex + supIndex)/2;
	moveHashCursor(hashCursor, hashTable, midIndex);
	
	while(infIndex <= supIndex){
		
		midIndex = (infIndex + supIndex)/2;
		moveHashCursor(hashCursor, hashTable, midIndex);

		if(hashID == hashCursor->hashID)
			return &(hashCursor->symbolList);

		if(hashCursor->hashID > hashID)
			supIndex = (midIndex - 1);
		else 
			infIndex = (midIndex + 1);
	}

	newHashElement = (HashElement*)malloc(sizeof(HashElement));

	if(NULL == newHashElement){

		logger("WARNING: Unable to allocate memory for new hash element in function 'getSymbolListByHashID'.");
		return NULL;
	}

	initHashElementByParam(newHashElement, hashID);

	/*
	Condition ' supIndex < midIndex ' is FORBIDDEN with unsigned types.
	Eg.: midIndex equals 0 and supIndex is decremented to -1 -> overflow.
	*/

	if(infIndex > midIndex){

		/* Insert after midIndex. */

		insertHashElementBetween(newHashElement, hashCursor, hashCursor->next);
	}
	else{

		/* Insert before midIndex. */

		insertHashElementBetween(newHashElement, hashCursor->prev, hashCursor);
	}

	++(hashTable->size);

	return &(newHashElement->symbolList);
}

/*
Function 'getSymbolBySymbolString': searches for a symbol in the given symbol list with
the given symbol string. If no symbol was found a new symbol list element is being added
to the symbol list with an appropriate symbol.
@param1: symbol list where the symbols are being stored.
@param2: symbol string in target of search.
@return: memory adress of the symbol specified by the given symbol string. In case of
error a NULL pointer is returned.
*/
Symbol* getSymbolBySymbolString(SymbolList *symbolList, const char symbolString[]){

	Symbol newSymbol;
	SymbolListElement *symbolListCursor = NULL, *newSymbolListElement = NULL;

	signed short int infIndex = 0, supIndex = (symbolList->size)-1, midIndex;

	midIndex = (infIndex + supIndex)/2;
	moveSymbolListCursor(symbolListCursor, symbolList, midIndex);

	while(infIndex <= supIndex){

		midIndex = (infIndex + supIndex)/2;
		moveSymbolListCursor(symbolListCursor, symbolList, midIndex);

		if(0 == strcmp(symbolString, symbolListCursor->symbol.symbolString))
			return &(symbolListCursor->symbol);

		if(strcmp(symbolString, symbolListCursor->symbol.symbolString) < 0)
			supIndex = (midIndex - 1);
		else
			infIndex = (midIndex + 1);
	}

	newSymbolListElement = (SymbolListElement*)malloc(sizeof(SymbolListElement));

	if(NULL == newSymbolListElement){

		logger("WARNING: Unable to allocate memory for new symbol list element in function 'getSymbolBySymbolString'.");
		return NULL;
	}

	initSymbolByParam(&newSymbol, symbolString, 0, 0.0);
	initSymbolListElementByParam(newSymbolListElement, &newSymbol);

	/*
	Condition ' supIndex < midIndex ' is FORBIDDEN with unsigned types.
	Eg.: midIndex equals 0 and supIndex is decremented to -1 -> overflow.
	*/

	if(infIndex > midIndex){

		/* Insert after midIndex. */

		insertSymbolListElementBetween(newSymbolListElement,symbolListCursor,symbolListCursor->next);
	}
	else{

		/* Insert before midIndex. */

		insertSymbolListElementBetween(newSymbolListElement,symbolListCursor->prev,symbolListCursor);
	}

	++(symbolList->size);

	return &(newSymbolListElement->symbol);
}

// Coder related functions

/*

*/
void generateShannonCode(HashTable *hashTable){

	BigSymbolList symbolList;
	initBigSymbolList(&symbolList);

	concatSymbolList(&symbolList, hashTable);

	quickSortByFrequency(&symbolList);

	// Calculate F for each symbol

	//TODO Generate Code and Write File
}

// File management related functions

/*
Function 'rawTextConverter': converts text to 'raw text' format.
@param1: name of the source file.
@param2: name of the target file.
@return: function status -1 (error) or 0 (success).
*/
int rawTextConverter(char sourceFileName[], char targetFileName[]){

	FILE *sourceFile=NULL, *targetFile=NULL;
	char character;

	sourceFile=fopen(sourceFileName,"r");

	if(sourceFile == NULL){
		logger("ERROR: Unable to open source file in function 'rawTextConverter'.");
		return -1;
	}

	targetFile=fopen(targetFileName,"w");

	if(targetFile == NULL){
		logger("ERROR: Unable to open target file in function 'rawTextConverter'.");
		fclose(sourceFile);
		sourceFile=NULL;
		return -1;
	}

	/* 
	Text converter cycle. Converts input text to 'raw text' by character.
	Upper case characters are being converted to lower case characters.
	Relevant characters: A-Z, a-z
	Other characters including numbers are being ignored.
	For conditions see the C language ASCII char table.
	Note that changes in conditions in function 'rawTextConverter' require
	the revision of the cycle core and conditions in function 'rawTextProcessor'.
	*/
	while(fscanf(sourceFile, "%c", &character) == 1){

		if(character > 0x40 && character < 0x5b){
			fprintf(targetFile, "%c", character+0x20);
		}
		else{
			if(character > 0x60 && character < 0x7b)
				fprintf(targetFile, "%c", character);
			else{
				if(character == 0x20)
					fprintf(targetFile, "%c", character);
				else
					/*void action*/;
			}
		}
	}

	fclose(sourceFile);
	sourceFile=NULL;
	fclose(targetFile);
	targetFile=NULL;

	return 0;
}

/*
Function 'rawTextProcessor': processes data from the 'raw text' file.
@param1: name of the 'raw text' file.
@param2: hash table where the processed data is being stored.
@return: function status -1 (error) or 0 (success).
*/
int rawTextProcessor(char rawTextFileName[], HashTable *hashTable){

	FILE *rawTextFile=NULL;
	int wordIndex=0;
	char character, word[WORD_ARRAY_SIZE];

	typedef enum{start, stop, space, letter} State;
	State currState=start;

	rawTextFile=fopen(rawTextFileName,"r");

	if(rawTextFile == NULL){
		logger("ERROR: Unable to open 'raw text' file in function 'rawTextProcessor'.");
		return -1;
	}

	/*
	Text processor cycle (state machine). Reads words (symbols) by character and adds them to
	a list containing symbols. Cycle conditions and data processing methods heavily
	depend on the character inventory of the 'raw text'. Note that changes in function
	'rawTextConverter' require the revision of the cycle core and conditions
	in function 'rawTextProcessor'.
	*/
	while(currState != stop){

		switch(currState){

		case start:

			if(fscanf(rawTextFile, "%c", &character) != 1)
				currState=stop;
			else
				if(character == ' ')
					currState=space;
				else{
					word[wordIndex]=character;
					++wordIndex;
					currState=letter;
				}
			break;

		case space:

			if(fscanf(rawTextFile, "%c", &character) != 1)
				currState=stop;
			else
				if(character == ' ')
					currState=space;
				else{
					word[wordIndex]=character;
					++wordIndex;
					currState=letter;
				}
			break;

		case letter:

			if(fscanf(rawTextFile, "%c", &character) != 1){
				word[wordIndex]='\0';
				if(addSymbol(word, hashTable) == 0)
					++TOTAL_SYMBOL_COUNT;
				wordIndex=0;
				currState=stop;
			}
			else
				if(character == ' '){
					word[wordIndex]='\0';
					if(addSymbol(word, hashTable) == 0)
						++TOTAL_SYMBOL_COUNT;
					wordIndex=0;
					currState=space;
				}
				else{
					if(wordIndex < (WORD_ARRAY_SIZE-1)){
						word[wordIndex]=character;
						++wordIndex;
						currState=letter;
					}
					else{ /*remains of the word being treated as a new word*/
						word[wordIndex]='\0';
						if(addSymbol(word, hashTable) == 0)
							++TOTAL_SYMBOL_COUNT;
						wordIndex=0;
						word[wordIndex]=character;
						++wordIndex;
						currState=letter;
						logger("WARNING: A word truncated in function 'rawTextProcessor'.\nGiven WORD_ARRAY_SIZE is exceeded.");
					}
					
				}
			break;
		}

	}

	fclose(rawTextFile);
	rawTextFile=NULL;

	return 0;
}


// Main function of the program 

int main(int argc, char* argv[])
{

	HashTable hashTable;

	logger("\t-\t-\t-\t-\t-\t-\t-NEW RUN-\t-\t-\t-\t-\t-\t-");

	/* Program Component Initialisation Block */

	printf("Initialising program components...\n");

	initHashTable(&hashTable);

	/* File Converter Block*/

	printf("Converting %s file...\n", RAW_FILE_NAME);

	if(rawTextConverter(argv[0],RAW_FILE_NAME) != 0){
		logger("ERROR: Function 'rawRextConverter' failed. Program terminated.");
		return -1;
	}

	/* File Reader Block */

	printf("Processing data. This might take a while...\n");

	if(rawTextProcessor(RAW_FILE_NAME, &hashTable) != 0){
		logger("ERROR: Function 'rawTextProcessor' failed. Program terminated.");
		return -1;
	}

	/* Shannon Coder and File Writer Block */

	printf("Generating Shannon code. This might take a while...\n");

	// TODO


	/* Program Component and Data Structure Decomposition free() */

	return 0;
}

/*
FUTURE DEVELOPMENT FIELDS:

1: Evaluate number of independent hashIDs and number of independent symbols per symbol list/hash element.
Use static arrays instead of dynamic arrays. Improve search algorythms due to static array by indexing.
Is contiguous memory allocation (static array!) possible with 'such' extension?

2: Optimize search algorithms by using relative indexing.
	(Eg.: moveHashCursor(lastCursorPos, relativeIndex{...}))

3: New data storage structure and algorithms based on alphabetical order, hash ID, symbol probability weigh.
	Tip#1:
		1st lvl -> Alphabetic groups according to 1st letter(and number) (A-Z,0-9)
		2nd lvl -> Hash tables according to hash IDs
		3rd lvl -> Symbols in alphabetic order in lists

4: Use const where possible (eg.: function parameter list)

5: Capability of processing numbers.

6: Check for valid references in functions on parameter list.
	Eg.: if(*ref_on_param == NULL){logger(...), return -1}

7: Rearrange function declaration and definition order.

8: Use function 'moveSymbolListCursor' instead of 'moveBigSymbolListCursor' by extending iter type range 
	(signed short int -> signed int)

9: Use protection against overindexing in each 'move[...]Cursor' function.

10: Move (increment) cursor (iCursor) in function 'partition' manually instead of calling the 'move[...]Cursor'
	function.

11: Revise working mechanism of function 'partition' and randomize pivot.

12: Allocate memory for symbol string using only sizeof(symbolString) with malloc in function 'initSymbolByParam'.

13: Use typedef for hash code type (unsigned short int). 

*/